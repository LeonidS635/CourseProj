<h1>
  <p align="center">
    Индивидуальный исследовательский проект<br>
    "Построение оптимальных путей передачи данных в сети"
  </p>
</h1>

## Введение
Целью данного курсового проекта является модифицирование существуюшего алгоритма, который используется для построения оптимальных путей передачи данных в сети с учётом ограничения на простоту пути, предложенного в статье "GRASP for traffic grooming and routing with simple path constraints in WDM mesh networks" авторства Xinyun Wu, Tao Ye, Qi Guo и Zhipeng Lu с целью улучшения его временной эффективности и/или качества решения в терминах итогового количества лайтпасов. Для этого была разработана модификация, которая предполагает проведения процесса груминга трафика сразу с учётом того, что лайтпасы не должны быть использованы сверх их пропускной способности, а также, что все пути для демандов должны быть простыми, в отличие от оригинальной версии алгоритма. Предполагается, что данная модификация улучшит временную эффективность алгоритма, что подтверждается тестированием.

## Архитектура программы
Модифицированный алгоритм имеет ту же структуру, что и оригинальный. В основном цикле программы итеративно выполняется построение и оптимизация решений с помощью функций Construct и LightpathMin.

В написанном алгоритме используются следующие вспомогательные структуры данных:
1. TrafficDemand — структура для хранения демандов. Имеет три поля: начальную и конечную вершины и запрашиваемый объём трафика.
2. Lightpath — структура для хранения лайтпасов. Имеет поля для хранения оставшейся пропускной способности лайтпаса и для хранения вершин, по которым идёт лайтпас.
3. Solution — структура для хранения решения, включает использование лайтпасов, связи между демандами и лайтпасами, а также общее количество используемых лайтпасов. Имеет методы для присвоения деманду лайтпасов, сброса этого присвоения и сброса всего решения.
4. Graph — структура для хранения сети. Используется для хранения как физической сети, так и для виртуальной. Данный класс использует алгоритм Флойда для подсчёта кратчайших дистанций между всеми парами вершин, алгоритм Дейкстры для нахождения кратчайшего пути между парой вершин для построения новых лайтпасов, а также модифицированный алгоритм DFS для построения путей из лайтпасов между двумя вершинами в виртуальной топологии. Отличие от обычного DFS заключается в том, что когда алгоритм находит путь до конечной вершины, вызывается функция, проверяющая, что путь корректный (все лайтпасы на пути имеют достаточное количество оставшейся пропускной способности для конкретного деманда, а также, что путь по физической сети для этого деманда является простым) и, если функция возвращает false, то поиск пути продолжается.

Сам алгоритм реализован в виде класса со следующими методами:
1. Run — основной цикл программы. Вызывает итеративно функции Construct и LightpathMin, пока не выполнено условие остановки. Возвращает лучшее решение с точки зрения количества лайтпасов.
2. Construct — функция, жадно строящее решение. Перед циклом деманды сортируются в порядке уменьшения количества используемых лайтпасов и сбрасывается текущее присвоение лайтпасов демандам (сами лайтпасы при этом остаются). В цикле перебираются деманды, и для каждого деманда назначается путь из лайтпасов.
3. LightpathMin — функция, оптимизирующее решение. В цикле последовательно удаляются лайтпасы, для каждого удалённого лайтпаса смотрятся деманды, которые через него проходили и вызывается функция Grooming, которая пытается перераспределить деманды. Если этого не получается сделать, лайтпас возвращается.
4. Grooming — функция, осуществляющая перераспределние лайтпасов. Она вызывает функцию GroomDemand, которая пытается найти путь для конкретного деманда, учитывая, что лайтпасы не должны быть использованы сверх пропускной способности и что путь для деманда должен быть простым. Если путь был найден, то прежде, чем назначать этот путь деманду, вызывается рекурсивно GroomDemand для следующего деманда. Останавливается рекурсия, когда какой-то вызов GroomDemand вернул false или когда все деманды были перенаправлены. Только в случае, если все деманды были перенаправлены, соответствующие пути будут присвоены демандам при раскрутке рекурсии.

## Тестирование
Для тестирования алгоритма были написаны следующие программы: генератор и валидатор. Генератор входных данных по заданному количеству вершин в физической сети и демандов генерирует случайный связный граф и случайные деманды. Валидатор решения проверяет корректность решения (все решения, выдаваемые алгоритмом проходят валидацию).

Для сравнения оригинального и модифицированного алгоритмов были выбраны несколько примеров сетей, описанных в статье, в которой описан исходный алгоритм. Результаты сравнения представлены в таблице ниже. Обозначим за Min количество лайтпасов в решении, за Time — среднее время исполнения одной итерации алгоритма, за Mode — наиболее часто встречающееся значение.

<div align="center">
  <table border="1">
    <tr>
      <th colspan="3"></th>
      <th colspan="2">Original</th>
      <th colspan="3">Modified</th>
    </tr>
    <tr>
      <td></td>
      <td><b>Nodes</b></td>
      <td><b>Demands</b></td>
      <td><b>Min</b></td>
      <td><b>Time, ms</b></td>
      <td><b>Min</b></td>
      <td><b>Mode</b></td>
      <td><b>Time, ms</b></td>
    </tr>
    <tr>
      <td>ring_1</td>
      <td>8</td>
      <td>15</td>
      <td>7</td>
      <td>100</td>
      <td>7</td>
      <td>7</td>
      <td>1</td>
    </tr>
    <tr>
      <td>ring_2</td>
      <td>10</td>
      <td>20</td>
      <td>9</td>
      <td>100</td>
      <td>8</td>
      <td>9</td>
      <td>1</td>
    </tr>
    <tr>
      <td>mesh_1</td>
      <td>10</td>
      <td>20</td>
      <td>9</td>
      <td>600</td>
      <td>9</td>
      <td>9</td>
      <td>2</td>
    </tr>
    <tr>
      <td>mesh_2</td>
      <td>10</td>
      <td>40</td>
      <td>11</td>
      <td>700</td>
      <td>12</td>
      <td>13</td>
      <td>15</td>
    </tr>
    <tr>
      <td>mesh_3</td>
      <td>10</td>
      <td>50</td>
      <td>12</td>
      <td>600</td>
      <td>14</td>
      <td>15</td>
      <td>40</td>
    </tr>
    <tr>
      <td>mesh_4</td>
      <td>10</td>
      <td>60</td>
      <td>17</td>
      <td>900</td>
      <td>16</td>
      <td>17</td>
      <td>100</td>
    </tr>
    <tr>
      <td>mesh_5</td>
      <td>10</td>
      <td>70</td>
      <td>18</td>
      <td>800</td>
      <td>18</td>
      <td>18</td>
      <td>230</td>
    </tr>
    <tr>
      <td>mesh_6</td>
      <td>10</td>
      <td>70</td>
      <td>17</td>
      <td>900</td>
      <td>18</td>
      <td>19</td>
      <td>250</td>
    </tr>
  </table>
</div>

Также модифицированный алгоритм был протестирован на случайных входных данных с количеством вершин: 10, 15, 20 и количеством демандов: 15, 50, 100. Результаты приведены в таблице  ниже:

<div align="center">
  <table border="1">
    <tr>
      <th colspan="2"></th>
      <th colspan="3">Modified</th>
    </tr>
    <tr>
      <td><b>Nodes</b></td>
      <td><b>Demands</b></td>
      <td><b>Min</b></td>
      <td><b>Mode</b></td>
      <td><b>Time, s</b></td>
    </tr>
    <tr>
      <td>10</td>
      <td>15</td>
      <td>9</td>
      <td>9</td>
      <td>0.002</td>
    </tr>
    <tr>
      <td>10</td>
      <td>50</td>
      <td>12</td>
      <td>12</td>
      <td>0.2</td>
    </tr>
    <tr>
      <td>10</td>
      <td>100</td>
      <td>18</td>
      <td>18</td>
      <td>8.5</td>
    </tr>
    <tr>
      <td>15</td>
      <td>15</td>
      <td>9</td>
      <td>9</td>
      <td>0.003</td>
    </tr>
    <tr>
      <td>15</td>
      <td>50</td>
      <td>20</td>
      <td>20</td>
      <td>2.2</td>
    </tr>
    <tr>
      <td>15</td>
      <td>100</td>
      <td>28</td>
      <td>29</td>
      <td>150</td>
    </tr>
    <tr>
      <td>20</td>
      <td>15</td>
      <td>11</td>
      <td>11</td>
      <td>0.004</td>
    </tr>
    <tr>
      <td>20</td>
      <td>50</td>
      <td>24</td>
      <td>24</td>
      <td>3</td>
    </tr>
    <tr>
      <td>20</td>
      <td>100</td>
      <td>35</td>
      <td>35</td>
      <td>210</td>
    </tr>
  </table>
</div>

Cтоит отметить, что так как деманды (и сеть во втором блоке тестов) генерируются случайным образом, результаты тестирования могут изменяться.

## Вывод
Основная цель курсового проекта была достигнута. Была предложена и имплементирована модификация алгоритма построения простых путей передачи данных в сети. Данная модификация улучшила время работы алгоритма, при этом модифицированный алгоритм в большинтве случаев не уступает или не сильно уступает по качеству решений в терминах количества лайтпасов оригинальному алгоритму. Однако стоит отметить, что сильный рост времени работы алгоритма при увеличении количества демандов может затруднить использование данного алгоритма на практике.
